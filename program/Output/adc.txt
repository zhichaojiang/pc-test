; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\adc.o --asm_dir=..\Output\ --list_dir=..\Output\ --depend=..\output\adc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS -I..\USER -I..\FWlib\inc -I..\FWlib\src -I..\modbus\include -I..\modbus\port -I..\modbus\rtu -I..\modbus\ascii -I..\modbus\include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -Id:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0 -D__UVISION_VERSION=535 -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=..\output\adc.crf adc.c]
                          THUMB

                          AREA ||i.ADC1_GPIO_Config||, CODE, READONLY, ALIGN=2

                  ADC1_GPIO_Config PROC
;;;23      */
;;;24     static void ADC1_GPIO_Config(void)
000000  b508              PUSH     {r3,lr}
;;;25     {
;;;26     	GPIO_InitTypeDef GPIO_InitStructure;
;;;27     	
;;;28     	/* Enable DMA clock */
;;;29     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;30     	
;;;31     	/* Enable ADC1 and GPIOC clock */
;;;32     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOA, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  f44f7001          MOV      r0,#0x204
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;33     	
;;;34     	/* Configure PA  as analog input */
;;;35     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;
000014  200f              MOVS     r0,#0xf
000016  f8ad0000          STRH     r0,[sp,#0]
;;;36     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00001a  2000              MOVS     r0,#0
00001c  f88d0003          STRB     r0,[sp,#3]
;;;37     	GPIO_Init(GPIOA, &GPIO_InitStructure);				//输入时不用设置速率
000020  4669              MOV      r1,sp
000022  4802              LDR      r0,|L1.44|
000024  f7fffffe          BL       GPIO_Init
;;;38     }
000028  bd08              POP      {r3,pc}
;;;39     
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      0x40010800

                          AREA ||i.ADC1_Init||, CODE, READONLY, ALIGN=1

                  ADC1_Init PROC
;;;114     */
;;;115    void ADC1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;116    {
;;;117    	ADC1_GPIO_Config();
000002  f7fffffe          BL       ADC1_GPIO_Config
;;;118    	ADC1_Mode_Config();
000006  f7fffffe          BL       ADC1_Mode_Config
;;;119    }
00000a  bd10              POP      {r4,pc}
;;;120    
                          ENDP


                          AREA ||i.ADC1_Mode_Config||, CODE, READONLY, ALIGN=2

                  ADC1_Mode_Config PROC
;;;40     
;;;41     static void ADC1_Mode_Config(void)
000000  b500              PUSH     {lr}
;;;42     {
000002  b091              SUB      sp,sp,#0x44
;;;43     	DMA_InitTypeDef DMA_InitStructure;
;;;44     	ADC_InitTypeDef ADC_InitStructure;
;;;45     	
;;;46     	/* DMA channel1 configuration */
;;;47     	DMA_DeInit(DMA1_Channel1);
000004  483f              LDR      r0,|L3.260|
000006  f7fffffe          BL       DMA_DeInit
;;;48     	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;	 //ADC地址
00000a  483f              LDR      r0,|L3.264|
00000c  9006              STR      r0,[sp,#0x18]
;;;49     	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)ADC_ConvertedValue;//内存地址
00000e  483f              LDR      r0,|L3.268|
000010  9007              STR      r0,[sp,#0x1c]
;;;50     	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
000012  2000              MOVS     r0,#0
000014  9008              STR      r0,[sp,#0x20]
;;;51     	DMA_InitStructure.DMA_BufferSize = 4;
000016  2004              MOVS     r0,#4
000018  9009              STR      r0,[sp,#0x24]
;;;52     	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//外设地址固定
00001a  2000              MOVS     r0,#0
00001c  900a              STR      r0,[sp,#0x28]
;;;53     	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  //内存地址固定
00001e  2080              MOVS     r0,#0x80
000020  900b              STR      r0,[sp,#0x2c]
;;;54     	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	//半字
000022  0040              LSLS     r0,r0,#1
000024  900c              STR      r0,[sp,#0x30]
;;;55     	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
000026  0080              LSLS     r0,r0,#2
000028  900d              STR      r0,[sp,#0x34]
;;;56     	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;		//循环传输
00002a  2020              MOVS     r0,#0x20
00002c  900e              STR      r0,[sp,#0x38]
;;;57     	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
00002e  0200              LSLS     r0,r0,#8
000030  900f              STR      r0,[sp,#0x3c]
;;;58     	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
000032  2000              MOVS     r0,#0
000034  9010              STR      r0,[sp,#0x40]
;;;59     	DMA_Init(DMA1_Channel1, &DMA_InitStructure);
000036  a906              ADD      r1,sp,#0x18
000038  4832              LDR      r0,|L3.260|
00003a  f7fffffe          BL       DMA_Init
;;;60     	
;;;61     	/* Enable DMA channel1 */
;;;62     	DMA_Cmd(DMA1_Channel1, ENABLE);
00003e  2101              MOVS     r1,#1
000040  4830              LDR      r0,|L3.260|
000042  f7fffffe          BL       DMA_Cmd
;;;63     	
;;;64     	/* ADC1 configuration */
;;;65     	
;;;66     	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;	//独立ADC模式
000046  2000              MOVS     r0,#0
000048  9001              STR      r0,[sp,#4]
;;;67     	ADC_InitStructure.ADC_ScanConvMode = ENABLE ; 	 //禁止扫描模式，扫描模式用于多通道采集
00004a  2001              MOVS     r0,#1
00004c  f88d0008          STRB     r0,[sp,#8]
;;;68     	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;	//开启连续转换模式，即不停地进行ADC转换
000050  f88d0009          STRB     r0,[sp,#9]
;;;69     	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;	//不使用外部触发转换
000054  f44f2060          MOV      r0,#0xe0000
000058  9003              STR      r0,[sp,#0xc]
;;;70     	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; 	//采集数据右对齐
00005a  2000              MOVS     r0,#0
00005c  9004              STR      r0,[sp,#0x10]
;;;71     	ADC_InitStructure.ADC_NbrOfChannel =4;	 	//要转换的通道数目1
00005e  2004              MOVS     r0,#4
000060  f88d0014          STRB     r0,[sp,#0x14]
;;;72     	ADC_Init(ADC1, &ADC_InitStructure);
000064  a901              ADD      r1,sp,#4
000066  4828              LDR      r0,|L3.264|
000068  384c              SUBS     r0,r0,#0x4c
00006a  f7fffffe          BL       ADC_Init
;;;73     	
;;;74     	/*配置ADC时钟，为PCLK2的8分频，即9Hz*/
;;;75     	RCC_ADCCLKConfig(RCC_PCLK2_Div8);
00006e  f44f4040          MOV      r0,#0xc000
000072  f7fffffe          BL       RCC_ADCCLKConfig
;;;76     
;;;77     	
;;;78     
;;;79     	/*配置ADC1的通道17为55.	5个采样周期，序列为1 */ 
;;;80     	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5);
000076  2305              MOVS     r3,#5
000078  2201              MOVS     r2,#1
00007a  2100              MOVS     r1,#0
00007c  4822              LDR      r0,|L3.264|
00007e  384c              SUBS     r0,r0,#0x4c
000080  f7fffffe          BL       ADC_RegularChannelConfig
;;;81     	/*配置ADC1的通道16为55.	5个采样周期，序列为1 */ 
;;;82     	ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 2, ADC_SampleTime_55Cycles5);
000084  2305              MOVS     r3,#5
000086  2202              MOVS     r2,#2
000088  2101              MOVS     r1,#1
00008a  481f              LDR      r0,|L3.264|
00008c  384c              SUBS     r0,r0,#0x4c
00008e  f7fffffe          BL       ADC_RegularChannelConfig
;;;83     	/*配置ADC1的通道11为55.	5个采样周期，序列为1 */ 
;;;84     	ADC_RegularChannelConfig(ADC1, ADC_Channel_2, 3, ADC_SampleTime_55Cycles5);
000092  2305              MOVS     r3,#5
000094  2203              MOVS     r2,#3
000096  2102              MOVS     r1,#2
000098  481b              LDR      r0,|L3.264|
00009a  384c              SUBS     r0,r0,#0x4c
00009c  f7fffffe          BL       ADC_RegularChannelConfig
;;;85       /*配置ADC1的通道11为55.	5个采样周期，序列为1 */ 
;;;86     	ADC_RegularChannelConfig(ADC1, ADC_Channel_3, 4, ADC_SampleTime_55Cycles5);
0000a0  2305              MOVS     r3,#5
0000a2  2204              MOVS     r2,#4
0000a4  2103              MOVS     r1,#3
0000a6  4818              LDR      r0,|L3.264|
0000a8  384c              SUBS     r0,r0,#0x4c
0000aa  f7fffffe          BL       ADC_RegularChannelConfig
;;;87     	
;;;88     	ADC_TempSensorVrefintCmd(ENABLE);
0000ae  2001              MOVS     r0,#1
0000b0  f7fffffe          BL       ADC_TempSensorVrefintCmd
;;;89     	/* Enable ADC1 DMA */
;;;90     	ADC_DMACmd(ADC1, ENABLE);
0000b4  2101              MOVS     r1,#1
0000b6  4814              LDR      r0,|L3.264|
0000b8  384c              SUBS     r0,r0,#0x4c
0000ba  f7fffffe          BL       ADC_DMACmd
;;;91     	
;;;92     	/* Enable ADC1 */
;;;93     	ADC_Cmd(ADC1, ENABLE);
0000be  2101              MOVS     r1,#1
0000c0  4811              LDR      r0,|L3.264|
0000c2  384c              SUBS     r0,r0,#0x4c
0000c4  f7fffffe          BL       ADC_Cmd
;;;94     	
;;;95     	/*复位校准寄存器 */   
;;;96     	ADC_ResetCalibration(ADC1);
0000c8  480f              LDR      r0,|L3.264|
0000ca  384c              SUBS     r0,r0,#0x4c
0000cc  f7fffffe          BL       ADC_ResetCalibration
;;;97     	/*等待校准寄存器复位完成 */
;;;98     	while(ADC_GetResetCalibrationStatus(ADC1));
0000d0  bf00              NOP      
                  |L3.210|
0000d2  480d              LDR      r0,|L3.264|
0000d4  384c              SUBS     r0,r0,#0x4c
0000d6  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000da  2800              CMP      r0,#0
0000dc  d1f9              BNE      |L3.210|
;;;99     	
;;;100    	/* ADC校准 */
;;;101    	ADC_StartCalibration(ADC1);
0000de  480a              LDR      r0,|L3.264|
0000e0  384c              SUBS     r0,r0,#0x4c
0000e2  f7fffffe          BL       ADC_StartCalibration
;;;102    	/* 等待校准完成*/
;;;103    	while(ADC_GetCalibrationStatus(ADC1));
0000e6  bf00              NOP      
                  |L3.232|
0000e8  4807              LDR      r0,|L3.264|
0000ea  384c              SUBS     r0,r0,#0x4c
0000ec  f7fffffe          BL       ADC_GetCalibrationStatus
0000f0  2800              CMP      r0,#0
0000f2  d1f9              BNE      |L3.232|
;;;104    	
;;;105    	/* 由于没有采用外部触发，所以使用软件触发ADC转换 */ 
;;;106    	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
0000f4  2101              MOVS     r1,#1
0000f6  4804              LDR      r0,|L3.264|
0000f8  384c              SUBS     r0,r0,#0x4c
0000fa  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;107    }
0000fe  b011              ADD      sp,sp,#0x44
000100  bd00              POP      {pc}
;;;108    /*
                          ENDP

000102  0000              DCW      0x0000
                  |L3.260|
                          DCD      0x40020008
                  |L3.264|
                          DCD      0x4001244c
                  |L3.268|
                          DCD      ADC_ConvertedValue

                          AREA ||i.ADC_average||, CODE, READONLY, ALIGN=2

                  ADC_average PROC
;;;123    *********************************************************************************/
;;;124    void ADC_average(void)
000000  2000              MOVS     r0,#0
;;;125    {
;;;126    	uint8_t i;
;;;127    	for(i=0;i<4;i++)
000002  e00b              B        |L4.28|
                  |L4.4|
;;;128    	{
;;;129    		ADC_1s_Value_cnt[i]=ADC_1s_Value_cnt[i]+ADC_ConvertedValue[i];		
000004  4916              LDR      r1,|L4.96|
000006  f8511020          LDR      r1,[r1,r0,LSL #2]
00000a  4a16              LDR      r2,|L4.100|
00000c  f8322010          LDRH     r2,[r2,r0,LSL #1]
000010  4411              ADD      r1,r1,r2
000012  4a13              LDR      r2,|L4.96|
000014  f8421020          STR      r1,[r2,r0,LSL #2]
000018  1c41              ADDS     r1,r0,#1              ;127
00001a  b2c8              UXTB     r0,r1                 ;127
                  |L4.28|
00001c  2804              CMP      r0,#4                 ;127
00001e  dbf1              BLT      |L4.4|
;;;130    	}
;;;131    	average_cnt++;
000020  4911              LDR      r1,|L4.104|
000022  8809              LDRH     r1,[r1,#0]  ; average_cnt
000024  1c49              ADDS     r1,r1,#1
000026  4a10              LDR      r2,|L4.104|
000028  8011              STRH     r1,[r2,#0]
;;;132    	if(average_cnt>=AVERAGE_TIME)
00002a  4611              MOV      r1,r2
00002c  8809              LDRH     r1,[r1,#0]  ; average_cnt
00002e  2932              CMP      r1,#0x32
000030  db14              BLT      |L4.92|
;;;133    	{
;;;134    	  average_cnt=0;	
000032  2100              MOVS     r1,#0
000034  8011              STRH     r1,[r2,#0]
;;;135    		
;;;136    		for(i=0;i<4;i++){
000036  2000              MOVS     r0,#0
000038  e00e              B        |L4.88|
                  |L4.58|
;;;137    			ADC_1s_Value_res[i]=ADC_1s_Value_cnt[i]/AVERAGE_TIME;
00003a  4909              LDR      r1,|L4.96|
00003c  f8511020          LDR      r1,[r1,r0,LSL #2]
000040  2232              MOVS     r2,#0x32
000042  fbb1f1f2          UDIV     r1,r1,r2
000046  4a09              LDR      r2,|L4.108|
000048  f8221010          STRH     r1,[r2,r0,LSL #1]
;;;138    			ADC_1s_Value_cnt[i]=0;
00004c  2100              MOVS     r1,#0
00004e  4a04              LDR      r2,|L4.96|
000050  f8421020          STR      r1,[r2,r0,LSL #2]
000054  1c41              ADDS     r1,r0,#1              ;136
000056  b2c8              UXTB     r0,r1                 ;136
                  |L4.88|
000058  2804              CMP      r0,#4                 ;136
00005a  dbee              BLT      |L4.58|
                  |L4.92|
;;;139    		}
;;;140    		
;;;141    	}
;;;142    }
00005c  4770              BX       lr
                          ENDP

00005e  0000              DCW      0x0000
                  |L4.96|
                          DCD      ADC_1s_Value_cnt
                  |L4.100|
                          DCD      ADC_ConvertedValue
                  |L4.104|
                          DCD      average_cnt
                  |L4.108|
                          DCD      ADC_1s_Value_res

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ADC_1s_Value_cnt
                          %        16

                          AREA ||.data||, DATA, ALIGN=1

                  ADC_ConvertedValue
                          %        8
                  ADC_1s_Value_res
000008  00000000          DCW      0x0000,0x0000
00000c  00000000          DCW      0x0000,0x0000
                  average_cnt
000010  0000              DCW      0x0000
